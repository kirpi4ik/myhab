buildscript {
    repositories {
        mavenCentral()
        gradlePluginPortal()
    }
    dependencies {
        // Temporarily commented out to resolve cache corruption issue
        // classpath 'com.bmuschko:gradle-nexus-plugin:2.3.1'
        classpath "com.bmuschko:gradle-docker-plugin:7.2.0"
        classpath 'commons-io:commons-io:2.6'
        classpath 'joda-time:joda-time:2.10.13'
    }
}

plugins {
    id "com.bmuschko.docker-remote-api" version "7.2.0"
}

//tag::import[]
import org.joda.time.DateTime;
import com.bmuschko.gradle.docker.tasks.image.*

//end::import[]

group "${projectGroup}"

allprojects {
    apply plugin: 'idea'

    repositories {
        mavenLocal()
        maven { url "https://repo.grails.org/grails/core" }
        maven { url "https://plugins.gradle.org/m2/" }
    }
}
//tag::extVariables[]
ext {
    isGrailsPlugin = name.startsWith('grails-plugin')
    isBuildSnapshot = projectVersion.toString().endsWith("-SNAPSHOT")
    commonBuild = new File(project.rootDir, "gradle").absolutePath
    dockerBuildDir = mkdir("${buildDir}/docker")
    dockerBuildGroup = 'Docker'
    dockerRegistry = 'index.docker.io'
    dockerRepo = 'myhab'
    tagId = "${projectVersion}"
    dockerTag = "${dockerRepo}:${tagId}" // <1>
}

//end::extVariables[]
//tag::prepareDocker[]
docker {
    registryCredentials {
        url = 'https://index.docker.io/v1/'
        def secret = file("${System.properties['user.home']}/.docker/hub.docker.com")
        if (secret.exists()) {
            username = secret.readLines().get(0)
            password = secret.readLines().get(1)
        }
    }
}
//tag::prepareDocker[]

subprojects { project ->
    version projectVersion
    group "${projectGroup}"

    ext {
        isGrailsApp = name.contains(project.name)
        isGrailsPlugin = name.startsWith('grails-plugin')
        isGrailsProject = isGrailsApp || isGrailsPlugin
        isBuildSnapshot = version.toString().endsWith("-SNAPSHOT")

    }
    
    // Configure Java toolchain to use Java 17 for all Java/Groovy projects
    afterEvaluate {
        // Apply to all projects that use Java/Groovy
        if (plugins.hasPlugin('java') || plugins.hasPlugin('groovy') || plugins.hasPlugin('java-library') || plugins.hasPlugin('org.grails.grails-web')) {
            // Use Java toolchain (requires Java 17 to be available)
            java {
                toolchain {
                    languageVersion = JavaLanguageVersion.of(17)
                }
            }
        }
    }
}

task syncVersionToPackageJson() {
    description = 'Sync version from gradle.properties to package.json'
    group = 'versioning'
    
    doLast {
        def packageJsonFile = new File("${projectDir}/client/web-vue3/package.json")
        if (packageJsonFile.exists()) {
            def packageJson = new groovy.json.JsonSlurper().parseText(packageJsonFile.text)
            packageJson.version = "${projectVersion}"
            packageJsonFile.text = groovy.json.JsonOutput.prettyPrint(groovy.json.JsonOutput.toJson(packageJson))
            logger.quiet "Updated package.json version to ${projectVersion}"
        }
    }
}

task syncVersionToEnvFiles() {
    description = 'Sync version from gradle.properties to .env and .env.prod'
    group = 'versioning'
    
    doLast {
        // Update .env file
        def envFile = new File("${projectDir}/client/web-vue3/.env")
        if (envFile.exists()) {
            def envContent = envFile.text
            envContent = envContent.replaceAll(/PRJ_VERSION=.*/, "PRJ_VERSION=${projectVersion}")
            envFile.text = envContent
            logger.quiet "Updated .env version to ${projectVersion}"
        }
        
        // Update .env.prod file
        def envProdFile = new File("${projectDir}/client/web-vue3/.env.prod")
        if (envProdFile.exists()) {
            def envProdContent = envProdFile.text
            envProdContent = envProdContent.replaceAll(/PRJ_VERSION=.*/, "PRJ_VERSION=${projectVersion}")
            envProdFile.text = envProdContent
            logger.quiet "Updated .env.prod version to ${projectVersion}"
        }
    }
}

task syncVersions(dependsOn: [syncVersionToPackageJson, syncVersionToEnvFiles]) {
    description = 'Sync version from gradle.properties to all project files'
    group = 'versioning'
    
    doLast {
        logger.quiet "âœ… All versions synchronized to ${projectVersion}"
    }
}

task versionTxt(dependsOn: syncVersions) {
    doLast {
        // Create docker directory if it doesn't exist
        def dockerDir = new File("${projectDir}/src/main/docker")
        if (!dockerDir.exists()) {
            dockerDir.mkdirs()
            logger.quiet "Created directory: ${dockerDir.absolutePath}"
        }
        
        // Generate version.txt
        new File(dockerDir, "version.txt").text = "${projectVersion}"
        
        // Generate app-entrypoint.sh
        def entrypointFile = new File(dockerDir, "app-entrypoint.sh")
        entrypointFile.text = """#!/bin/sh
set -e
java -jar -Dgrails.env=\$GRAILS_ENV /app/myhab.jar \$@
"""
        // Make the script executable (Unix-like systems)
        entrypointFile.setExecutable(true)
    }
}
task serve(dependsOn: ':web-vue3:serve') {
    group = 'application'
    description = 'Run the Quasar development server for the web client'
}

task copyClientResources(dependsOn: [':web-vue3:build']) { // <1>
    group = 'build'
    description = 'Copy client resources into server'
    doLast {
        copy {
            from project(':web-vue3').buildDir.absolutePath
            into "${project(':server-core').buildDir}/resources/main/public"
        }
    }
}

task assembleServerAndClient(dependsOn: ['copyClientResources', 'versionTxt', ':server-core:assemble']) { // <2>
    group = 'build'
    description = 'Build combined server & web-vue3 JAR/WAR'

    doLast {
        copy {
            from fileTree(dir: "${project(':server-core').buildDir}/libs/") // <3>
            into "${buildDir}"
        }

        logger.quiet "JAR/WAR generated at $rootDir/build/. It combines the server and web-vue3 projects."
    }
}

copyClientResources.doFirst { // <4>
    copy {
        from "${project(':web-vue3').projectDir}/dist/spa"
        into "${project(':server-core').buildDir}/resources/main/public"
    }
}

task prepareDocker(type: Copy, dependsOn: assembleServerAndClient) { // <3>
    description = 'Copy files from src/main/docker and application jar to Docker temporal build directory'
    group = dockerBuildGroup
    into dockerBuildDir
    into(".") {
        from 'src/main/docker'
        from "${buildDir}/${projectName}-${projectVersion}.jar"
    }

    eachFile { logger.quiet("## ${it.file.absolutePath} | ${it.file.length()}") }
}
//end::prepareDocker[]

//tag::createDockerfile[]
task createDockerfile(type: Dockerfile, dependsOn: prepareDocker) { // <4>
    description = 'Create a Dockerfile file'
    group = dockerBuildGroup

    destFile = project.file("${dockerBuildDir}/Dockerfile")

    from 'eclipse-temurin:17-jre'

    label(['project': 'myHAB'])
    label(['version': "${projectVersion}"])
    label(['org.opencontainers.image.authors': 'Dumitru Ciubenco "dumitru.ciubenco@gmail.com"'])

    exposePort 8181
    environmentVariable 'GRAILS_ENV', 'production'
    // Create a config directory and expose as volume.
    // External configuration files in this volume are automatically
    // picked up.
    runCommand 'mkdir -p /app/config'
    volume '/app/config'
    workingDir '/app'

    copyFile "${projectName}-${projectVersion}.jar", "${projectName}.jar"
    copyFile 'app-entrypoint.sh', 'app-entrypoint.sh' // <5>
    runCommand 'chmod +x app-entrypoint.sh'

    entryPoint '/app/app-entrypoint.sh' // <5>
}
//end::createDockerfile[]

//tag::buildImage[]
task buildImage(type: DockerBuildImage, dependsOn: createDockerfile) { // <6>
    description = 'Create Docker image to run the Grails application'
    group = dockerBuildGroup

    inputDir = file(dockerBuildDir)
    images.add("${githubSlug}:${tagId}")
}
task tagImage(type: DockerTagImage, dependsOn: buildImage) {
    description "Tag custom docker image."
    group = dockerBuildGroup
    targetImageId buildImage.getImageId()
    repository = "${githubSlug}".toString()
    tag = "${tagId}"
}

task pushImage(type: DockerPushImage, dependsOn: tagImage) {
    group = dockerBuildGroup
    description "Push custom docker image."

    images.add("${githubSlug}:${tagId}".toString())
}
//end::buildImage[]
task removeImage(type: DockerRemoveImage) {
    description = 'Remove Docker image with Grails application.'
    group = dockerBuildGroup
    targetImageId { dockerTag }
}
//apply from: "${commonBuild}/common-publishing.gradle"
